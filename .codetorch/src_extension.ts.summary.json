[
  {
    "liveCode": "export function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('Congratulations, your extension \"codetorch\" is now active!');\n\toutputChannel.show(true);\n\tlog('CodeTorch extension activated');\n\n\t// === CodeTorch Status Bar Quick Menu ===\n\tlet codelensProviderRef: { refresh: () => void; handleDocumentSave: (doc: vscode.TextDocument) => void } | undefined;\n\tconst statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);\n\tstatusBar.command = 'codetorch.showQuickMenu';\n\n\t// Helper to keep the status bar in sync with user settings\n\tconst updateStatusBar = () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\t\tif (!enabled) {\n\t\t\tstatusBar.text = '$(circle-slash) CodeTorch Off';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries generation disabled';\n\t\t} else if (!visible) {\n\t\t\tstatusBar.text = '$(eye-closed) CodeTorch Hidden';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries hidden (generation active)';\n\t\t} else {\n\t\t\tstatusBar.text = '$(symbol-function) CodeTorch On';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries visible';\n\t\t}\n\t\tlog('Updated status bar');\n\t\tstatusBar.show();\n\t\t// Trigger CodeLens refresh immediately\n\t\tif (codelensProviderRef) {\n\t\t\tcodelensProviderRef.refresh();\n\t\t}\n\t};\n\n\tupdateStatusBar();\n\tcontext.subscriptions.push(statusBar);\n\n\t// Command that shows a quick-pick menu to toggle CodeTorch options\n\tconst quickMenuDisposable = vscode.commands.registerCommand('codetorch.showQuickMenu', async () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\n\t\tconst selected = await vscode.window.showQuickPick([\n\t\t\t{ label: `${visible ? '$(check)' : '$(x)'} Summaries Visibility`, description: visible ? 'Currently ON – click to turn OFF' : 'Currently OFF – click to turn ON' },\n\t\t\t{ label: `${enabled ? '$(check)' : '$(x)'} Summaries Generation`, description: enabled ? 'Currently ENABLED – click to DISABLE' : 'Currently DISABLED – click to ENABLE' }\n\t\t], { placeHolder: 'CodeTorch settings' });\n\n\t\tif (!selected) { return; }\n\n\t\tif (selected.label.includes('Visibility')) {\n\t\t\tawait cfg.update('showSummaries', !visible, vscode.ConfigurationTarget.Global);\n\t\t} else if (selected.label.includes('Generation')) {\n\t\t\tconst newEnabled = !enabled;\n\t\t\tawait cfg.update('enableSummaries', newEnabled, vscode.ConfigurationTarget.Global);\n\t\t\tif (!newEnabled) {\n\t\t\t\tawait cfg.update('showSummaries', false, vscode.ConfigurationTarget.Global);\n\t\t\t}\n\t\t}\n\n\t\tupdateStatusBar();\n\t});\n\tcontext.subscriptions.push(quickMenuDisposable);\n\n\t// React to configuration changes made elsewhere\n\tconst cfgListener = vscode.workspace.onDidChangeConfiguration(e => {\n\t\tif (e.affectsConfiguration('codetorch.showSummaries') || e.affectsConfiguration('codetorch.enableSummaries')) {\n\t\t\tupdateStatusBar();\n\t\t}\n\t});\n\tcontext.subscriptions.push(cfgListener);\n\n\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tconst disposable = vscode.commands.registerCommand('codetorch.helloWorld', () => {\n\t\t// The code you place here will be executed every time your command is executed\n\t\t// Display a message box to the user\n\t\tvscode.window.showInformationMessage('Hello World from CodeTorch!');\n\t});\n\n\tconst annotateDisposable = vscode.commands.registerCommand('codetorch.annotateCurrentFile', () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to annotate.');\n\t\t\treturn;\n\t\t}\n\n\t\tdetectFunctions(editor.document).then((functions) => {\n\t\t\tif (functions.length === 0) {\n\t\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst list = functions.map((f: FunctionInfo) => `• ${f.name} (line ${f.startLine + 1})`).join('\\n');\n\t\t\tvscode.window.showInformationMessage(`Detected functions:\\n${list}`);\n\t\t});\n\t});\n\n\tconst summarizeDisposable = vscode.commands.registerCommand('codetorch.summarizeFunction', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to summarize.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst cursorLine = editor.selection.active.line;\n\n\t\tconst functions = await detectFunctions(document);\n\t\tif (functions.length === 0) {\n\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Find the function that contains the cursor\n\t\tlet current: FunctionInfo | undefined;\n\t\tfor (let i = 0; i < functions.length; i++) {\n\t\t\tconst fn = functions[i];\n\t\t\tconst nextStart = (i + 1 < functions.length) ? functions[i + 1].startLine : document.lineCount;\n\t\t\tif (cursorLine >= fn.startLine && cursorLine < nextStart) {\n\t\t\t\tcurrent = fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!current) {\n\t\t\tvscode.window.showInformationMessage('Cursor is not inside any detected function.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst fnStart = current.startLine;\n\t\tconst nextStart = functions\n\t\t\t.filter(f => f.startLine > fnStart)\n\t\t\t.map(f => f.startLine)\n\t\t\t.sort((a, b) => a - b)[0] ?? document.lineCount;\n\n\t\tconst code = document.getText(new vscode.Range(fnStart, 0, nextStart, 0));\n\n\t\t// Call LLM summariser\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - compiled JS requires explicit extension\n\t\t\tconst { summarizeFunction } = await import('./llm.js');\n\t\t\tconst summary = await summarizeFunction(code, document.languageId);\n\t\t\tvscode.window.showInformationMessage(summary, { modal: true });\n\t\t} catch (err: any) {\n\t\t\tconsole.error('LLM summarization failed', err);\n\t\t\tvscode.window.showErrorMessage('LLM summarization failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\t// Collect call graph (current file)\n\tconst callGraphDisposable = vscode.commands.registerCommand('codetorch.collectCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to analyse.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await computeCallGraph(editor.document);\n\t\t\tawait saveCallGraph(editor.document, graph);\n\t\t\tlog('Call graph saved', graph);\n\t\t\tvscode.window.showInformationMessage(`Call graph collected for ${graph.length} functions.`);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Call graph generation failed', err);\n\t\t\tvscode.window.showErrorMessage('Call graph generation failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\t// View call graph (current file)\n\tconst viewCallGraphDisposable = vscode.commands.registerCommand('codetorch.viewCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to view.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await loadCallGraph<CallGraphEntry[]>(editor.document);\n\t\t\tif (!graph) {\n\t\t\t\tvscode.window.showInformationMessage('No call graph data found. Run \"Collect Call Graph\" first.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create a formatted view of the call graph\n\t\t\tconst formattedGraph = graph.map((entry: CallGraphEntry) => {\n\t\t\t\treturn `${entry.name}:\n Callers (depth 1): ${entry.depth1Callers.length > 0 ? entry.depth1Callers.join(', ') : 'none'}\n Callers (depth 2): ${entry.depth2Callers.length > 0 ? entry.depth2Callers.join(', ') : 'none'}\n Callees (depth 1): ${entry.depth1Callees.length > 0 ? entry.depth1Callees.join(', ') : 'none'}\n Callees (depth 2): ${entry.depth2Callees.length > 0 ? entry.depth2Callees.join(', ') : 'none'}`;\n\t\t\t}).join('\\n\\n');\n\n\t\t\t// Show in a new document\n\t\t\tconst doc = await vscode.workspace.openTextDocument({\n\t\t\t\tcontent: `Call Graph for ${editor.document.fileName}:\\n\\n${formattedGraph}`,\n\t\t\t\tlanguage: 'markdown'\n\t\t\t});\n\t\t\tawait vscode.window.showTextDocument(doc);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Failed to view call graph:', err);\n\t\t\tvscode.window.showErrorMessage('Failed to view call graph: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\tconst regenerateDisposable = vscode.commands.registerCommand('codetorch.regenerateSummaries', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to regenerate.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!codelensProviderRef) {\n\t\t\tvscode.window.showErrorMessage('CodeTorch not initialised yet.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt to save the document so that it is not dirty; this guarantees summarisation runs\n\t\tawait editor.document.save();\n\n\t\t// Mimic the save-triggered regeneration explicitly\n\t\tcodelensProviderRef.handleDocumentSave(editor.document);\n\t});\n\tcontext.subscriptions.push(regenerateDisposable);\n\n\tconst noopDisposable = vscode.commands.registerCommand('codetorch.nop', () => {});\n\n\t// Test if DocumentSymbolProvider is available for a given document\n\tconst testDocumentSymbolProvider = async (document: vscode.TextDocument): Promise<boolean> => {\n\t\ttry {\n\t\t\tconst symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(\n\t\t\t\t'vscode.executeDocumentSymbolProvider',\n\t\t\t\tdocument.uri\n\t\t\t);\n\t\t\t// If we get a result (even empty array), the provider is available\n\t\t\treturn Array.isArray(symbols);\n\t\t} catch (error) {\n\t\t\tlog('DocumentSymbolProvider test failed:', error);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t// Wait for DocumentSymbolProvider to be available with max delay\n\tconst waitForDocumentSymbolProvider = async (maxDelayMs: number = 10000): Promise<boolean> => {\n\t\tconst startTime = Date.now();\n\t\tconst checkInterval = 100; // Check every 100ms\n\t\t\n\t\twhile (Date.now() - startTime < maxDelayMs) {\n\t\t\t// Try to find a document to test with\n\t\t\tlet testDocument: vscode.TextDocument | undefined;\n\t\t\t\n\t\t\tif (vscode.window.activeTextEditor) {\n\t\t\t\ttestDocument = vscode.window.activeTextEditor.document;\n\t\t\t} else {\n\t\t\t\t// Try to get any open document\n\t\t\t\tconst documents = vscode.workspace.textDocuments;\n\t\t\t\ttestDocument = documents.find(doc => doc.uri.scheme === 'file');\n\t\t\t}\n\t\t\t\n\t\t\tif (testDocument) {\n\t\t\t\tconst isAvailable = await testDocumentSymbolProvider(testDocument);\n\t\t\t\tif (isAvailable) {\n\t\t\t\t\tlog('DocumentSymbolProvider is available');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Wait before next check\n\t\t\tawait new Promise(resolve => setTimeout(resolve, checkInterval));\n\t\t}\n\t\t\n\t\tlog('DocumentSymbolProvider not available after timeout');\n\t\treturn false;\n\t};\n\n\t// Defer CodeLens provider registration until language services are ready\n\tconst initializeCodeLensProvider = async () => {\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore - extension .js added at build time\n\t\tconst mod = await import('./codelens.js');\n\t\tconst codelensProvider = new mod.FunctionSummaryCodeLensProvider();\n\t\tcodelensProviderRef = codelensProvider;\n\t\tcontext.subscriptions.push(\n\t\t\tvscode.languages.registerCodeLensProvider({ scheme: 'file' }, codelensProvider)\n\t\t);\n\n\t\t// Refresh summaries on document save\n\t\tconst saveListener = vscode.workspace.onDidSaveTextDocument((doc) => {\n\t\t\tconst trigger = vscode.workspace.getConfiguration('codetorch').get<string>('regenerationTrigger', 'onSave');\n\t\t\tif (trigger === 'onSave') {\n\t\t\t\tcodelensProvider.handleDocumentSave(doc);\n\t\t\t}\n\t\t});\n\t\tcontext.subscriptions.push(saveListener);\n\n\t\t// Lightweight live shift on each edit (no LLM calls)\n\t\tconst changeListener = vscode.workspace.onDidChangeTextDocument((e)=>{\n\t\t\tcodelensProvider.handleTextDocumentChange(e);\n\t\t});\n\t\tcontext.subscriptions.push(changeListener);\n\n\t\t// Register dispose handler for the codelens provider\n\t\tcontext.subscriptions.push({\n\t\t\tdispose: () => codelensProvider.dispose()\n\t\t});\n\n\t\tlog('CodeLens provider initialized');\n\t};\n\n\t// Initialize CodeLens provider when DocumentSymbolProvider is ready\n\tconst initializeWhenReady = async () => {\n\t\tlog('Waiting for DocumentSymbolProvider to be available...');\n\t\tconst isReady = await waitForDocumentSymbolProvider(10000); // 10 second max delay\n\t\t\n\t\tif (isReady) {\n\t\t\tawait initializeCodeLensProvider();\n\t\t} else {\n\t\t\tlog('DocumentSymbolProvider not available, initializing CodeLens provider anyway');\n\t\t\tawait initializeCodeLensProvider();\n\t\t}\n\t};\n\n\t// Start initialization\n\tinitializeWhenReady();\n\n\tcontext.subscriptions.push(noopDisposable);\n}\n\n// This method is called when your extension is deactivated\n",
    "lastSavedCode": "export function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('Congratulations, your extension \"codetorch\" is now active!');\n\toutputChannel.show(true);\n\tlog('CodeTorch extension activated');\n\n\t// === CodeTorch Status Bar Quick Menu ===\n\tlet codelensProviderRef: { refresh: () => void; handleDocumentSave: (doc: vscode.TextDocument) => void } | undefined;\n\tconst statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);\n\tstatusBar.command = 'codetorch.showQuickMenu';\n\n\t// Helper to keep the status bar in sync with user settings\n\tconst updateStatusBar = () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\t\tif (!enabled) {\n\t\t\tstatusBar.text = '$(circle-slash) CodeTorch Off';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries generation disabled';\n\t\t} else if (!visible) {\n\t\t\tstatusBar.text = '$(eye-closed) CodeTorch Hidden';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries hidden (generation active)';\n\t\t} else {\n\t\t\tstatusBar.text = '$(symbol-function) CodeTorch On';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries visible';\n\t\t}\n\t\tlog('Updated status bar');\n\t\tstatusBar.show();\n\t\t// Trigger CodeLens refresh immediately\n\t\tif (codelensProviderRef) {\n\t\t\tcodelensProviderRef.refresh();\n\t\t}\n\t};\n\n\tupdateStatusBar();\n\tcontext.subscriptions.push(statusBar);\n\n\t// Command that shows a quick-pick menu to toggle CodeTorch options\n\tconst quickMenuDisposable = vscode.commands.registerCommand('codetorch.showQuickMenu', async () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\n\t\tconst selected = await vscode.window.showQuickPick([\n\t\t\t{ label: `${visible ? '$(check)' : '$(x)'} Summaries Visibility`, description: visible ? 'Currently ON – click to turn OFF' : 'Currently OFF – click to turn ON' },\n\t\t\t{ label: `${enabled ? '$(check)' : '$(x)'} Summaries Generation`, description: enabled ? 'Currently ENABLED – click to DISABLE' : 'Currently DISABLED – click to ENABLE' }\n\t\t], { placeHolder: 'CodeTorch settings' });\n\n\t\tif (!selected) { return; }\n\n\t\tif (selected.label.includes('Visibility')) {\n\t\t\tawait cfg.update('showSummaries', !visible, vscode.ConfigurationTarget.Global);\n\t\t} else if (selected.label.includes('Generation')) {\n\t\t\tconst newEnabled = !enabled;\n\t\t\tawait cfg.update('enableSummaries', newEnabled, vscode.ConfigurationTarget.Global);\n\t\t\tif (!newEnabled) {\n\t\t\t\tawait cfg.update('showSummaries', false, vscode.ConfigurationTarget.Global);\n\t\t\t}\n\t\t}\n\n\t\tupdateStatusBar();\n\t});\n\tcontext.subscriptions.push(quickMenuDisposable);\n\n\t// React to configuration changes made elsewhere\n\tconst cfgListener = vscode.workspace.onDidChangeConfiguration(e => {\n\t\tif (e.affectsConfiguration('codetorch.showSummaries') || e.affectsConfiguration('codetorch.enableSummaries')) {\n\t\t\tupdateStatusBar();\n\t\t}\n\t});\n\tcontext.subscriptions.push(cfgListener);\n\n\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tconst disposable = vscode.commands.registerCommand('codetorch.helloWorld', () => {\n\t\t// The code you place here will be executed every time your command is executed\n\t\t// Display a message box to the user\n\t\tvscode.window.showInformationMessage('Hello World from CodeTorch!');\n\t});\n\n\tconst annotateDisposable = vscode.commands.registerCommand('codetorch.annotateCurrentFile', () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to annotate.');\n\t\t\treturn;\n\t\t}\n\n\t\tdetectFunctions(editor.document).then((functions) => {\n\t\t\tif (functions.length === 0) {\n\t\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst list = functions.map((f: FunctionInfo) => `• ${f.name} (line ${f.startLine + 1})`).join('\\n');\n\t\t\tvscode.window.showInformationMessage(`Detected functions:\\n${list}`);\n\t\t});\n\t});\n\n\tconst summarizeDisposable = vscode.commands.registerCommand('codetorch.summarizeFunction', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to summarize.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst cursorLine = editor.selection.active.line;\n\n\t\tconst functions = await detectFunctions(document);\n\t\tif (functions.length === 0) {\n\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Find the function that contains the cursor\n\t\tlet current: FunctionInfo | undefined;\n\t\tfor (let i = 0; i < functions.length; i++) {\n\t\t\tconst fn = functions[i];\n\t\t\tconst nextStart = (i + 1 < functions.length) ? functions[i + 1].startLine : document.lineCount;\n\t\t\tif (cursorLine >= fn.startLine && cursorLine < nextStart) {\n\t\t\t\tcurrent = fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!current) {\n\t\t\tvscode.window.showInformationMessage('Cursor is not inside any detected function.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst fnStart = current.startLine;\n\t\tconst nextStart = functions\n\t\t\t.filter(f => f.startLine > fnStart)\n\t\t\t.map(f => f.startLine)\n\t\t\t.sort((a, b) => a - b)[0] ?? document.lineCount;\n\n\t\tconst code = document.getText(new vscode.Range(fnStart, 0, nextStart, 0));\n\n\t\t// Call LLM summariser\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - compiled JS requires explicit extension\n\t\t\tconst { summarizeFunction } = await import('./llm.js');\n\t\t\tconst summary = await summarizeFunction(code, document.languageId);\n\t\t\tvscode.window.showInformationMessage(summary, { modal: true });\n\t\t} catch (err: any) {\n\t\t\tconsole.error('LLM summarization failed', err);\n\t\t\tvscode.window.showErrorMessage('LLM summarization failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\t// Collect call graph (current file)\n\tconst callGraphDisposable = vscode.commands.registerCommand('codetorch.collectCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to analyse.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await computeCallGraph(editor.document);\n\t\t\tawait saveCallGraph(editor.document, graph);\n\t\t\tlog('Call graph saved', graph);\n\t\t\tvscode.window.showInformationMessage(`Call graph collected for ${graph.length} functions.`);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Call graph generation failed', err);\n\t\t\tvscode.window.showErrorMessage('Call graph generation failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\t// View call graph (current file)\n\tconst viewCallGraphDisposable = vscode.commands.registerCommand('codetorch.viewCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to view.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await loadCallGraph<CallGraphEntry[]>(editor.document);\n\t\t\tif (!graph) {\n\t\t\t\tvscode.window.showInformationMessage('No call graph data found. Run \"Collect Call Graph\" first.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create a formatted view of the call graph\n\t\t\tconst formattedGraph = graph.map((entry: CallGraphEntry) => {\n\t\t\t\treturn `${entry.name}:\n Callers (depth 1): ${entry.depth1Callers.length > 0 ? entry.depth1Callers.join(', ') : 'none'}\n Callers (depth 2): ${entry.depth2Callers.length > 0 ? entry.depth2Callers.join(', ') : 'none'}\n Callees (depth 1): ${entry.depth1Callees.length > 0 ? entry.depth1Callees.join(', ') : 'none'}\n Callees (depth 2): ${entry.depth2Callees.length > 0 ? entry.depth2Callees.join(', ') : 'none'}`;\n\t\t\t}).join('\\n\\n');\n\n\t\t\t// Show in a new document\n\t\t\tconst doc = await vscode.workspace.openTextDocument({\n\t\t\t\tcontent: `Call Graph for ${editor.document.fileName}:\\n\\n${formattedGraph}`,\n\t\t\t\tlanguage: 'markdown'\n\t\t\t});\n\t\t\tawait vscode.window.showTextDocument(doc);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Failed to view call graph:', err);\n\t\t\tvscode.window.showErrorMessage('Failed to view call graph: ' + (err?.message ?? err));\n\t\t}\n\t});\n\n\tconst regenerateDisposable = vscode.commands.registerCommand('codetorch.regenerateSummaries', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to regenerate.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!codelensProviderRef) {\n\t\t\tvscode.window.showErrorMessage('CodeTorch not initialised yet.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt to save the document so that it is not dirty; this guarantees summarisation runs\n\t\tawait editor.document.save();\n\n\t\t// Mimic the save-triggered regeneration explicitly\n\t\tcodelensProviderRef.handleDocumentSave(editor.document);\n\t});\n\tcontext.subscriptions.push(regenerateDisposable);\n\n\tconst noopDisposable = vscode.commands.registerCommand('codetorch.nop', () => {});\n\n\t// Test if DocumentSymbolProvider is available for a given document\n\tconst testDocumentSymbolProvider = async (document: vscode.TextDocument): Promise<boolean> => {\n\t\ttry {\n\t\t\tconst symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(\n\t\t\t\t'vscode.executeDocumentSymbolProvider',\n\t\t\t\tdocument.uri\n\t\t\t);\n\t\t\t// If we get a result (even empty array), the provider is available\n\t\t\treturn Array.isArray(symbols);\n\t\t} catch (error) {\n\t\t\tlog('DocumentSymbolProvider test failed:', error);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t// Wait for DocumentSymbolProvider to be available with max delay\n\tconst waitForDocumentSymbolProvider = async (maxDelayMs: number = 10000): Promise<boolean> => {\n\t\tconst startTime = Date.now();\n\t\tconst checkInterval = 100; // Check every 100ms\n\t\t\n\t\twhile (Date.now() - startTime < maxDelayMs) {\n\t\t\t// Try to find a document to test with\n\t\t\tlet testDocument: vscode.TextDocument | undefined;\n\t\t\t\n\t\t\tif (vscode.window.activeTextEditor) {\n\t\t\t\ttestDocument = vscode.window.activeTextEditor.document;\n\t\t\t} else {\n\t\t\t\t// Try to get any open document\n\t\t\t\tconst documents = vscode.workspace.textDocuments;\n\t\t\t\ttestDocument = documents.find(doc => doc.uri.scheme === 'file');\n\t\t\t}\n\t\t\t\n\t\t\tif (testDocument) {\n\t\t\t\tconst isAvailable = await testDocumentSymbolProvider(testDocument);\n\t\t\t\tif (isAvailable) {\n\t\t\t\t\tlog('DocumentSymbolProvider is available');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Wait before next check\n\t\t\tawait new Promise(resolve => setTimeout(resolve, checkInterval));\n\t\t}\n\t\t\n\t\tlog('DocumentSymbolProvider not available after timeout');\n\t\treturn false;\n\t};\n\n\t// Defer CodeLens provider registration until language services are ready\n\tconst initializeCodeLensProvider = async () => {\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore - extension .js added at build time\n\t\tconst mod = await import('./codelens.js');\n\t\tconst codelensProvider = new mod.FunctionSummaryCodeLensProvider();\n\t\tcodelensProviderRef = codelensProvider;\n\t\tcontext.subscriptions.push(\n\t\t\tvscode.languages.registerCodeLensProvider({ scheme: 'file' }, codelensProvider)\n\t\t);\n\n\t\t// Refresh summaries on document save\n\t\tconst saveListener = vscode.workspace.onDidSaveTextDocument((doc) => {\n\t\t\tconst trigger = vscode.workspace.getConfiguration('codetorch').get<string>('regenerationTrigger', 'onSave');\n\t\t\tif (trigger === 'onSave') {\n\t\t\t\tcodelensProvider.handleDocumentSave(doc);\n\t\t\t}\n\t\t});\n\t\tcontext.subscriptions.push(saveListener);\n\n\t\t// Lightweight live shift on each edit (no LLM calls)\n\t\tconst changeListener = vscode.workspace.onDidChangeTextDocument((e)=>{\n\t\t\tcodelensProvider.handleTextDocumentChange(e);\n\t\t});\n\t\tcontext.subscriptions.push(changeListener);\n\n\t\t// Register dispose handler for the codelens provider\n\t\tcontext.subscriptions.push({\n\t\t\tdispose: () => codelensProvider.dispose()\n\t\t});\n\n\t\tlog('CodeLens provider initialized');\n\t};\n\n\t// Initialize CodeLens provider when DocumentSymbolProvider is ready\n\tconst initializeWhenReady = async () => {\n\t\tlog('Waiting for DocumentSymbolProvider to be available...');\n\t\tconst isReady = await waitForDocumentSymbolProvider(10000); // 10 second max delay\n\t\t\n\t\tif (isReady) {\n\t\t\tawait initializeCodeLensProvider();\n\t\t} else {\n\t\t\tlog('DocumentSymbolProvider not available, initializing CodeLens provider anyway');\n\t\t\tawait initializeCodeLensProvider();\n\t\t}\n\t};\n\n\t// Start initialization\n\tinitializeWhenReady();\n\n\tcontext.subscriptions.push(noopDisposable);\n}\n\n// This method is called when your extension is deactivated\n",
    "startLine": 10,
    "units": [
      {
        "line": 1,
        "chunkCode": "export function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('Congratulations, your extension \"codetorch\" is now active!');\n\toutputChannel.show(true);\n\tlog('CodeTorch extension activated');\n",
        "summary": "The `activate` function serves as the entry point for the VS Code extension, performing initial setup and logging."
      },
      {
        "line": 9,
        "chunkCode": "\t// === CodeTorch Status Bar Quick Menu ===\n\tlet codelensProviderRef: { refresh: () => void; handleDocumentSave: (doc: vscode.TextDocument) => void } | undefined;\n\tconst statusBar = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Right, 100);\n\tstatusBar.command = 'codetorch.showQuickMenu';\n\n\t// Helper to keep the status bar in sync with user settings\n\tconst updateStatusBar = () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\t\tif (!enabled) {\n\t\t\tstatusBar.text = '$(circle-slash) CodeTorch Off';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries generation disabled';\n\t\t} else if (!visible) {\n\t\t\tstatusBar.text = '$(eye-closed) CodeTorch Hidden';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries hidden (generation active)';\n\t\t} else {\n\t\t\tstatusBar.text = '$(symbol-function) CodeTorch On';\n\t\t\tstatusBar.tooltip = 'CodeTorch summaries visible';\n\t\t}\n\t\tlog('Updated status bar');\n\t\tstatusBar.show();\n\t\t// Trigger CodeLens refresh immediately\n\t\tif (codelensProviderRef) {\n\t\t\tcodelensProviderRef.refresh();\n\t\t}\n\t};\n\n\tupdateStatusBar();\n\tcontext.subscriptions.push(statusBar);\n",
        "summary": "A status bar item is created and configured to display the CodeTorch status based on user settings, with a helper function to update its text and tooltip."
      },
      {
        "line": 40,
        "chunkCode": "\t// Command that shows a quick-pick menu to toggle CodeTorch options\n\tconst quickMenuDisposable = vscode.commands.registerCommand('codetorch.showQuickMenu', async () => {\n\t\tconst cfg = vscode.workspace.getConfiguration('codetorch');\n\t\tconst visible = cfg.get<boolean>('showSummaries', true);\n\t\tconst enabled = cfg.get<boolean>('enableSummaries', true);\n\n\t\tconst selected = await vscode.window.showQuickPick([\n\t\t\t{ label: `${visible ? '$(check)' : '$(x)'} Summaries Visibility`, description: visible ? 'Currently ON – click to turn OFF' : 'Currently OFF – click to turn ON' },\n\t\t\t{ label: `${enabled ? '$(check)' : '$(x)'} Summaries Generation`, description: enabled ? 'Currently ENABLED – click to DISABLE' : 'Currently DISABLED – click to ENABLE' }\n\t\t], { placeHolder: 'CodeTorch settings' });\n\n\t\tif (!selected) { return; }\n\n\t\tif (selected.label.includes('Visibility')) {\n\t\t\tawait cfg.update('showSummaries', !visible, vscode.ConfigurationTarget.Global);\n\t\t} else if (selected.label.includes('Generation')) {\n\t\t\tconst newEnabled = !enabled;\n\t\t\tawait cfg.update('enableSummaries', newEnabled, vscode.ConfigurationTarget.Global);\n\t\t\tif (!newEnabled) {\n\t\t\t\tawait cfg.update('showSummaries', false, vscode.ConfigurationTarget.Global);\n\t\t\t}\n\t\t}\n\n\t\tupdateStatusBar();\n\t});\n\tcontext.subscriptions.push(quickMenuDisposable);\n",
        "summary": "A command is registered to open a quick-pick menu allowing users to toggle summaries visibility and generation, updating settings and the status bar accordingly."
      },
      {
        "line": 67,
        "chunkCode": "\t// React to configuration changes made elsewhere\n\tconst cfgListener = vscode.workspace.onDidChangeConfiguration(e => {\n\t\tif (e.affectsConfiguration('codetorch.showSummaries') || e.affectsConfiguration('codetorch.enableSummaries')) {\n\t\t\tupdateStatusBar();\n\t\t}\n\t});\n\tcontext.subscriptions.push(cfgListener);\n",
        "summary": "A listener is set up to react to configuration changes related to CodeTorch summaries, updating the status bar when settings are modified."
      },
      {
        "line": 75,
        "chunkCode": "\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tconst disposable = vscode.commands.registerCommand('codetorch.helloWorld', () => {\n\t\t// The code you place here will be executed every time your command is executed\n\t\t// Display a message box to the user\n\t\tvscode.window.showInformationMessage('Hello World from CodeTorch!');\n\t});\n",
        "summary": "A basic \"Hello World\" command is registered, displaying an informational message when executed."
      },
      {
        "line": 84,
        "chunkCode": "\tconst annotateDisposable = vscode.commands.registerCommand('codetorch.annotateCurrentFile', () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to annotate.');\n\t\t\treturn;\n\t\t}\n\n\t\tdetectFunctions(editor.document).then((functions) => {\n\t\t\tif (functions.length === 0) {\n\t\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst list = functions.map((f: FunctionInfo) => `• ${f.name} (line ${f.startLine + 1})`).join('\\n');\n\t\t\tvscode.window.showInformationMessage(`Detected functions:\\n${list}`);\n\t\t});\n\t});\n",
        "summary": "A command is registered to detect and display a list of functions found within the currently active text editor."
      },
      {
        "line": 102,
        "chunkCode": "\tconst summarizeDisposable = vscode.commands.registerCommand('codetorch.summarizeFunction', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to summarize.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst document = editor.document;\n\t\tconst cursorLine = editor.selection.active.line;\n\n\t\tconst functions = await detectFunctions(document);\n\t\tif (functions.length === 0) {\n\t\t\tvscode.window.showInformationMessage('No functions detected in current file.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Find the function that contains the cursor\n\t\tlet current: FunctionInfo | undefined;\n\t\tfor (let i = 0; i < functions.length; i++) {\n\t\t\tconst fn = functions[i];\n\t\t\tconst nextStart = (i + 1 < functions.length) ? functions[i + 1].startLine : document.lineCount;\n\t\t\tif (cursorLine >= fn.startLine && cursorLine < nextStart) {\n\t\t\t\tcurrent = fn;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!current) {\n\t\t\tvscode.window.showInformationMessage('Cursor is not inside any detected function.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst fnStart = current.startLine;\n\t\tconst nextStart = functions\n\t\t\t.filter(f => f.startLine > fnStart)\n\t\t\t.map(f => f.startLine)\n\t\t\t.sort((a, b) => a - b)[0] ?? document.lineCount;\n\n\t\tconst code = document.getText(new vscode.Range(fnStart, 0, nextStart, 0));\n\n\t\t// Call LLM summariser\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t\t// @ts-ignore - compiled JS requires explicit extension\n\t\t\tconst { summarizeFunction } = await import('./llm.js');\n\t\t\tconst summary = await summarizeFunction(code, document.languageId);\n\t\t\tvscode.window.showInformationMessage(summary, { modal: true });\n\t\t} catch (err: any) {\n\t\t\tconsole.error('LLM summarization failed', err);\n\t\t\tvscode.window.showErrorMessage('LLM summarization failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n",
        "summary": "A command is registered to summarize the function at the current cursor position by extracting its code and sending it to an LLM."
      },
      {
        "line": 155,
        "chunkCode": "\t// Collect call graph (current file)\n\tconst callGraphDisposable = vscode.commands.registerCommand('codetorch.collectCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to analyse.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await computeCallGraph(editor.document);\n\t\t\tawait saveCallGraph(editor.document, graph);\n\t\t\tlog('Call graph saved', graph);\n\t\t\tvscode.window.showInformationMessage(`Call graph collected for ${graph.length} functions.`);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Call graph generation failed', err);\n\t\t\tvscode.window.showErrorMessage('Call graph generation failed: ' + (err?.message ?? err));\n\t\t}\n\t});\n",
        "summary": "A command is registered to compute and save a call graph for the functions in the current file."
      },
      {
        "line": 174,
        "chunkCode": "\t// View call graph (current file)\n\tconst viewCallGraphDisposable = vscode.commands.registerCommand('codetorch.viewCallGraphCurrentFile', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to view.');\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst graph = await loadCallGraph<CallGraphEntry[]>(editor.document);\n\t\t\tif (!graph) {\n\t\t\t\tvscode.window.showInformationMessage('No call graph data found. Run \"Collect Call Graph\" first.');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Create a formatted view of the call graph\n\t\t\tconst formattedGraph = graph.map((entry: CallGraphEntry) => {\n\t\t\t\treturn `${entry.name}:\n Callers (depth 1): ${entry.depth1Callers.length > 0 ? entry.depth1Callers.join(', ') : 'none'}\n Callers (depth 2): ${entry.depth2Callers.length > 0 ? entry.depth2Callers.join(', ') : 'none'}\n Callees (depth 1): ${entry.depth1Callees.length > 0 ? entry.depth1Callees.join(', ') : 'none'}\n Callees (depth 2): ${entry.depth2Callees.length > 0 ? entry.depth2Callees.join(', ') : 'none'}`;\n\t\t\t}).join('\\n\\n');\n\n\t\t\t// Show in a new document\n\t\t\tconst doc = await vscode.workspace.openTextDocument({\n\t\t\t\tcontent: `Call Graph for ${editor.document.fileName}:\\n\\n${formattedGraph}`,\n\t\t\t\tlanguage: 'markdown'\n\t\t\t});\n\t\t\tawait vscode.window.showTextDocument(doc);\n\t\t} catch (err: any) {\n\t\t\tconsole.error('Failed to view call graph:', err);\n\t\t\tvscode.window.showErrorMessage('Failed to view call graph: ' + (err?.message ?? err));\n\t\t}\n\t});\n",
        "summary": "A command is registered to load and display a previously saved call graph for the current file in a new document."
      },
      {
        "line": 210,
        "chunkCode": "\tconst regenerateDisposable = vscode.commands.registerCommand('codetorch.regenerateSummaries', async () => {\n\t\tconst editor = vscode.window.activeTextEditor;\n\t\tif (!editor) {\n\t\t\tvscode.window.showErrorMessage('No active editor to regenerate.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!codelensProviderRef) {\n\t\t\tvscode.window.showErrorMessage('CodeTorch not initialised yet.');\n\t\t\treturn;\n\t\t}\n\n\t\t// Attempt to save the document so that it is not dirty; this guarantees summarisation runs\n\t\tawait editor.document.save();\n\n\t\t// Mimic the save-triggered regeneration explicitly\n\t\tcodelensProviderRef.handleDocumentSave(editor.document);\n\t});\n\tcontext.subscriptions.push(regenerateDisposable);\n",
        "summary": "A command is registered to explicitly trigger the regeneration of summaries for the active file."
      },
      {
        "line": 230,
        "chunkCode": "\tconst noopDisposable = vscode.commands.registerCommand('codetorch.nop', () => {});\n",
        "summary": "A no-operation command is registered, which performs no action when invoked."
      },
      {
        "line": 232,
        "chunkCode": "\t// Test if DocumentSymbolProvider is available for a given document\n\tconst testDocumentSymbolProvider = async (document: vscode.TextDocument): Promise<boolean> => {\n\t\ttry {\n\t\t\tconst symbols = await vscode.commands.executeCommand<vscode.DocumentSymbol[]>(\n\t\t\t\t'vscode.executeDocumentSymbolProvider',\n\t\t\t\tdocument.uri\n\t\t\t);\n\t\t\t// If we get a result (even empty array), the provider is available\n\t\t\treturn Array.isArray(symbols);\n\t\t} catch (error) {\n\t\t\tlog('DocumentSymbolProvider test failed:', error);\n\t\t\treturn false;\n\t\t}\n\t};\n\n\t// Wait for DocumentSymbolProvider to be available with max delay\n\tconst waitForDocumentSymbolProvider = async (maxDelayMs: number = 10000): Promise<boolean> => {\n\t\tconst startTime = Date.now();\n\t\tconst checkInterval = 100; // Check every 100ms\n\t\t\n\t\twhile (Date.now() - startTime < maxDelayMs) {\n\t\t\t// Try to find a document to test with\n\t\t\tlet testDocument: vscode.TextDocument | undefined;\n\t\t\t\n\t\t\tif (vscode.window.activeTextEditor) {\n\t\t\t\ttestDocument = vscode.window.activeTextEditor.document;\n\t\t\t} else {\n\t\t\t\t// Try to get any open document\n\t\t\t\tconst documents = vscode.workspace.textDocuments;\n\t\t\t\ttestDocument = documents.find(doc => doc.uri.scheme === 'file');\n\t\t\t}\n\t\t\t\n\t\t\tif (testDocument) {\n\t\t\t\tconst isAvailable = await testDocumentSymbolProvider(testDocument);\n\t\t\t\tif (isAvailable) {\n\t\t\t\t\tlog('DocumentSymbolProvider is available');\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// Wait before next check\n\t\t\tawait new Promise(resolve => setTimeout(resolve, checkInterval));\n\t\t}\n\t\t\n\t\tlog('DocumentSymbolProvider not available after timeout');\n\t\treturn false;\n\t};\n",
        "summary": "Utility functions are defined to test for and asynchronously wait until the Document Symbol Provider is available from VS Code's language services."
      },
      {
        "line": 280,
        "chunkCode": "\t// Defer CodeLens provider registration until language services are ready\n\tconst initializeCodeLensProvider = async () => {\n\t\t// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n\t\t// @ts-ignore - extension .js added at build time\n\t\tconst mod = await import('./codelens.js');\n\t\tconst codelensProvider = new mod.FunctionSummaryCodeLensProvider();\n\t\tcodelensProviderRef = codelensProvider;\n\t\tcontext.subscriptions.push(\n\t\t\tvscode.languages.registerCodeLensProvider({ scheme: 'file' }, codelensProvider)\n\t\t);\n\n\t\t// Refresh summaries on document save\n\t\tconst saveListener = vscode.workspace.onDidSaveTextDocument((doc) => {\n\t\t\tconst trigger = vscode.workspace.getConfiguration('codetorch').get<string>('regenerationTrigger', 'onSave');\n\t\t\tif (trigger === 'onSave') {\n\t\t\t\tcodelensProvider.handleDocumentSave(doc);\n\t\t\t}\n\t\t});\n\t\tcontext.subscriptions.push(saveListener);\n\n\t\t// Lightweight live shift on each edit (no LLM calls)\n\t\tconst changeListener = vscode.workspace.onDidChangeTextDocument((e)=>{\n\t\t\tcodelensProvider.handleTextDocumentChange(e);\n\t\t});\n\t\tcontext.subscriptions.push(changeListener);\n\n\t\t// Register dispose handler for the codelens provider\n\t\tcontext.subscriptions.push({\n\t\t\tdispose: () => codelensProvider.dispose()\n\t\t});\n\n\t\tlog('CodeLens provider initialized');\n\t};\n",
        "summary": "An asynchronous function is defined to initialize the CodeLens provider, registering it with VS Code and setting up listeners for document save and change events."
      },
      {
        "line": 314,
        "chunkCode": "\t// Initialize CodeLens provider when DocumentSymbolProvider is ready\n\tconst initializeWhenReady = async () => {\n\t\tlog('Waiting for DocumentSymbolProvider to be available...');\n\t\tconst isReady = await waitForDocumentSymbolProvider(10000); // 10 second max delay\n\t\t\n\t\tif (isReady) {\n\t\t\tawait initializeCodeLensProvider();\n\t\t} else {\n\t\t\tlog('DocumentSymbolProvider not available, initializing CodeLens provider anyway');\n\t\t\tawait initializeCodeLensProvider();\n\t\t}\n\t};\n\n\t// Start initialization\n\tinitializeWhenReady();\n\n\tcontext.subscriptions.push(noopDisposable);\n}\n\n// This method is called when your extension is deactivated\n",
        "summary": "The initialization process is orchestrated to defer the CodeLens provider registration, waiting for the Document Symbol Provider to be ready, then proceeds with initialization."
      }
    ]
  },
  {
    "liveCode": "export function deactivate() {}\n",
    "lastSavedCode": "export function deactivate() {}\n",
    "startLine": 343,
    "units": [
      {
        "line": 1,
        "chunkCode": "export function deactivate() {}\n",
        "summary": "This code defines an empty `deactivate` function, likely intended to be called when a module or extension is unloaded or disabled."
      }
    ]
  }
]